<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Matt Aimonetti]]></title>
  <link href="http://mattetti.github.com/articles/categories/golang/atom.xml" rel="self"/>
  <link href="http://mattetti.github.com/"/>
  <updated>2014-04-30T00:01:49-07:00</updated>
  <id>http://mattetti.github.com/</id>
  <author>
    <name><![CDATA[Matt Aimonetti]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go, Robots and code refactoring]]></title>
    <link href="http://mattetti.github.com/posts/2014/04/28/refactoring-go-code/"/>
    <updated>2014-04-28T10:45:00-07:00</updated>
    <id>http://mattetti.github.com/posts/2014/04/28/refactoring-go-code</id>
    <content type="html"><![CDATA[<p><a href="http://golang.org/">Go</a> aka golang is an amazing language but also a language that
is really easy to learn due to its small scope.
If you have some coding experience, you will be able to have fully working code
in a matter of minutes otherwise you might want to read <a href="http://www.golangbootcamp.com/">my free book</a> (WIP).</p>

<div style="text-align:center; padding:2em 0">
  <a href="http://www.golangbootcamp.com/"><img src="http://mattetti.github.com/images/matt_aimonetti-go_bootcamp.png" alt="Go Bootcamp free book (golang)"></a>
</div>


<p>Very much like with many other programming languages, a challenging part
of Go is to learn how to write idiomatic code.
The good news is that Go makes refactoring easy (and already has a lot
of conventions).
I strongly recommend <a href="http://peter.bourgon.org/go-in-production/">this post</a> from Peter Bourgon about Go at SoundCloud and
the extra conventions they follow (<a href="https://splice.com">Splice</a> also
follows the same conventions).</p>

<p>One of my favorite Go projects is the <a href="http://gobot.io">gobot</a> project
by <a href="http://hybridgroup.com/">HybridGroup</a>.</p>

<div style="text-align:center; padding:2em 0">
<a href="http://gobot.io/"><img src="http://mattetti.github.com/images/gobotio.png" alt="Gobot"></a>
</div>


<p>The Gobot project is pretty young and I noticed a few things that
could be improved so I offered my help to <a href="https://twitter.com/deadprogram">Ron</a>,
<a href="https://twitter.com/adzankich">Adrian</a> and the rest of the team.
Our discussion quickly turned into a fun group refactoring
session (featuring <a href="https://twitter.com/kytrinyx">@kytrinyx</a>,
<a href="https://twitter.com/deadprogram">@deadprogram</a>,
<a href="https://twitter.com/codegangsta">@codegangsta</a>,
<a href="https://twitter.com/jnbeck">@jnbeck</a>,
<a href="https://twitter.com/adzankich">@adzankich</a> )</p>

<div style="text-align:center; padding:2em 0">
  <img src="http://mattetti.github.com/images/matt_aimonetti-go_refactoring.jpg" alt="Go refactoring at GopherCon">
</div>


<h2>Packages</h2>

<p>Gobot is split into multiple packages, a core and a few other packages.
The gobot team, out of habit chose to put a package per repo.
After further discussions, we chose to bring all official packages
inside the same repo to keep things easier and to keep the import paths
clean and logical.</p>

<p>So instead of having:</p>

<p><code>
github.com/hybridgroup/gobot
github.com/hybridgroup/gobot-sphero
github.com/hybridgroup/gobot-...
</code></p>

<p>All the none-core packages are moved to subdirectories:</p>

<p><code>
github.com/hybridgroup/gobot
github.com/hybridgroup/gobot/sphero
github.com/hybridgroup/gobot/...
</code></p>

<p>This also allowed us to fix the package names
<code>gobot-sphero</code> is now simply <code>sphero</code></p>

<p>Which also allowed us to simplify the following code:</p>

<p>From:
```go
type SpheroAdaptor struct {</p>

<pre><code>gobot.Adaptor
sp io.ReadWriteCloser
</code></pre>

<p>}
```</p>

<p>To</p>

<p><code>go
type Adaptor struct {
  gobot.Adaptor
  sp io.ReadWriteCloser
}
</code></p>

<p>We did that with a few other types and methods all over the packages.</p>

<p>We had a discussion about what lead to the multiple repos vs
one repo. There are legimiate cases for both approaches but in this
situation, the decision was based on a misunderstanding. The author
thought that by importing the top package, all sub packages would
also be somewhat included in the build, making the binary bigger than
needed. Since Go only compiles and links packages imported, moving all
packages within the same repo wouldn't change the binary output.
Note that this is not because in this specific case we have all packages
in the same repo that this is the right thing to do every single time.</p>

<h2>doc.go</h2>

<p>By conventions, package should contain a <code>doc.go</code> file that contains
an overview of the package and often some information so the developer
trying to use the library can find the right entry points.</p>

<p>As usual, the standard libraries are a good example,
<a href="http://golang.org/src/pkg/net/http/doc.go">here is the net/http <code>doc.go</code> file</a>.</p>

<h2>Using a constructor</h2>

<p>We spent some time refactoring <code>master.go</code> which is the file implementing
the code handling one or multiple robots (which can each have multiple devices).</p>

<p>The original function code looked like this:</p>

<p><code>go
func GobotMaster() *Master {
  m := new(Master)
  m.NumCPU = runtime.NumCPU()
  return m
}
</code></p>

<p>There are a few things that aren't really idiomatic in this code.
The first thing is that by convention, constructors are usually called <code>New&lt;Type&gt;</code>.
Secondly, the <a href="http://peter.bourgon.org/go-in-production/">community seems to follow</a> the following stylistic choice:
only use <code>new</code> and <code>make</code> when you need to set the capacity (<code>make([]string,3)</code>)
Finally we don't need to allocate a variable. Here is the refactored code:</p>

<p><code>go
func NewMaster() *Master {
  return &amp;Master{NumCPU: runtime.NumCPU()}
}
</code></p>

<h2>Cleanup package vars</h2>

<p>In the original code, we had a variable called <code>trap</code> which was
a function living at the top level of the package:</p>

<p><code>go
var trap = func(c chan os.Signal) {
  signal.Notify(c, os.Interrupt)
}
</code></p>

<p>The func was then used to handle signals. The author
chose to use a variable so he could mutate it in the test suite and
avoid sending an interrupt when testing.
We realized we could avoid having this function variable at the top of the package by moving
it as a field on the <code>Master</code> type and setting the default func in the constructor.</p>

<p>```go
func NewMaster() *Master {</p>

<pre><code>return &amp;Master{
    NumCPU: runtime.NumCPU(),
    trap: func(c chan os.Signal) {
        signal.Notify(c, os.Interrupt)
    },
}
</code></pre>

<p>}
```</p>

<p>The code still behaves the same and we can still overwrite the trap function in our tests
(since the tests are part of the same packge, the non exported field is available)
but we got rid of a top level var.</p>

<h2>Reading from a channel</h2>

<p>The following code was ranging over a predefined channel (<code>c</code>) of signals.
and when a signal would arrive, all robots belonging to the master
would be halted and disconnected.</p>

<p>```go
for _ = range c {
  for r := range m.Robots {</p>

<pre><code>m.Robots[r].haltDevices()
m.Robots[r].finalizeConnections()
</code></pre>

<p>  }
  break
}
```</p>

<p>The code above works well but could be cleaned up a little:</p>

<p>```go
// waiting on something coming on the channel
&lt;- c
for _, r := range m.Robots {</p>

<pre><code>r.haltDevices()
r.finalizeConnections()
</code></pre>

<p>}
```</p>

<p>This code does the same thing but simpler.
We are trying to read from the channel which will block
(we don't care about the result so we don't capture or could have used an underscore).
Then we loop through each robot and stop them.
We managed to remove a for loop on the channel (with an odd break)
and me made the code intent clearer.</p>

<h2>Chainable functions and typed nils</h2>

<p>Next, we tacked the following method:</p>

<p>```go
func (m <em>Master) FindRobotDevice(name string, device string) </em>device {</p>

<pre><code>robot := m.FindRobot(name)
if robot != nil {
    return robot.GetDevice(device)
}
return nil
</code></pre>

<p>}
```</p>

<p>The funny thing about this method is that it's not needed.
We could get the same result by calling:</p>

<p><code>go
m.FindRobot("bot name").GetDevice("laser")
</code></p>

<p>When I said that, someone suggested that it might be a bad idea
since <code>FindRobot()</code> might return <code>nil</code> and now we would be calling
<code>GetDevice()</code> on <code>nil</code> and bad things would happen.
Looking at the code, it was actually easy to fix.</p>

<p>Here is the original code:</p>

<p>```go
func (r <em>Robot) GetDevice(name string) </em>device {</p>

<pre><code>for _, device := range r.devices {
    if device.Name == name {
        return device
    }
}
return nil
</code></pre>

<p>}
```</p>

<p>Here is the refactored version:</p>

<p>```go
func (r <em>Robot) GetDevice(name string) </em>device {</p>

<pre><code>if r == nil {
    return nil
}
for _, device := range r.devices {
    if device.Name == name {
        return device
    }
}
return nil
</code></pre>

<p>}
```</p>

<p>Did you spot the difference? We just added a check to see if the pointer (<code>r</code>)
was nil, if it is, we just return <code>nil</code>.
When I added the code above, the person who was worried
about calling <code>GetDevice()</code> on <code>nil</code> was scratching his head.</p>

<p>Golang does something very interesting (and a bit surprising if you come
from a dynamic language),
it returns a nil pointer of the type we defined as return type.
Let's walk through the code by rewriting it slightly differently:</p>

<p><code>go
var bot *Robot
bot = m.FindRobot("unknown name")
</code></p>

<p>At this point if <code>FindRobot()</code> didn't find a robot, <code>bot</code> is still
of type <code>*Robot</code> but the pointer is nil.
Because we defined a method <code>GetDevice()</code> on <code>*Robot</code>, we
can call:</p>

<p><code>go
bot.GetDevice("x-ray")
</code></p>

<p>The <code>GetDevice()</code> method will execute and will return <code>nil</code> right
away because we check if the pointer is <code>nil</code>.</p>

<p>The fact that nil pointers have types has 2 important implications,
the first one is that you can nicely chain methods without
checking at the caller site if the returned value is <code>nil</code>.
The second is that your methods should expect to be potentially
called on a nil pointer and should properly handle such cases.</p>

<p><strong>Note</strong>: Go team member <a href="https://twitter.com/enneff">Andrew Gerrand</a>
suggested on <a href="https://news.ycombinator.com/item?id=7667554">Hacker News</a>
to name the method <code>Device</code> instead of <code>GetDevice</code>. The word <code>Get</code> is almost always redundant.
In the same chain of thoughts, maybe we should rename <code>FindRobot</code> just <code>Robot</code>.</p>

<h2>Collection types / type aliasing</h2>

<p>I'm writing this post on my way back from GopherCon and there
was one more thing I wanted to clean up and share with you.
This is a nice pattern I use often to simplify my code.</p>

<p>Our <code>Robot</code> type has a <code>connections</code> field and a <code>devices</code> field:</p>

<p>```go
type Robot struct {
  // .. fields removed to simplify the example</p>

<pre><code>devices       []*device
</code></pre>

<p>}
```</p>

<p>To avoid always having to manually loop through the slice, a method is defined on
pointers to <code>Robot</code>. This method iterates over
the devices and halts them:</p>

<p>```go
func (r *Robot) haltDevices() {</p>

<pre><code>for _, device := range r.devices {
    device.Halt()
}
</code></pre>

<p>}
```</p>

<p>This code is totally fine but from an API design perspective wouldn't be nicer
to use:</p>

<p><code>go
r.devices().Halt()
</code></p>

<p>One of the nice things with this approach is that the concept of halting which
really belongs to the devices doesn't need to leak into the <code>Robot</code> world.</p>

<p>To implement the suggested API change, we need to define a <a href="http://www.golangbootcamp.com/book/methods_and_interfaces#uid90">type alias</a>:</p>

<p><code>go
type DeviceCollection []*device
</code></p>

<p>We can now define methods on our new type:</p>

<p>```go
func (c DeviceCollection) Halt() {
  for _, device := range c {</p>

<pre><code>device.Halt()
</code></pre>

<p>  }
}
```</p>

<p>We then need to update our <code>Robot</code> type:</p>

<p><code>go
type Robot struct {
  // .. fields removed to simplify the example
  devices       DeviceCollection
}
</code></p>

<p>And we are done with our refactoring.</p>

<p>One last note, since we might be need to call different methods on our collection
we could create an iterator method.</p>

<p>```go
func (c DeviceCollection) Each(f func(*device)) {
  for _, d := range c {</p>

<pre><code>f(d)
</code></pre>

<p>  }
}</p>

<p>// which can be called like so
r.devices.Each(func(d *device){
  d.Halt()
})
```</p>

<h2>Conclusion</h2>

<p>Needless to say that we had fun. The refactoring went much further
and we removed the use of reflections, some sleeps and much more.
The code is going through a nice cleanup before reaching 1.0 and
I can only encourage everybody to play with <a href="http://gobot.io">Gobot</a>,
there are very few things as fun as Go and Robots!
(The code is open sourced, look at it, add new drivers, send PRs!)</p>

<p>I'd like to thank <a href="https://twitter.com/deadprogram">Ron Evans</a> and the <a href="http://hybridgroup.com/">Hybrid Group</a>
for  open sourcing their code and sharing the fun with all of us.
I can't wait for the next LA Go + Robot hack night.</p>

<p>Finally, <a href="https://splice.com">Splice</a> is hiring, our stack uses a lot of
different technologies but our backend is all in Go and we are always
looking for tatented engineers. Drop me a line if interested.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What technology should my startup use?]]></title>
    <link href="http://mattetti.github.com/posts/2013/08/27/what-technology-should-my-startup-use/"/>
    <updated>2013-08-27T22:10:00-07:00</updated>
    <id>http://mattetti.github.com/posts/2013/08/27/what-technology-should-my-startup-use</id>
    <content type="html"><![CDATA[<p>Over the years many people have asked me the same question:</p>

<blockquote><p>I'm starting this new project, what technology do you think I should use?</p></blockquote>

<p>Often these people fit in one of two categories:</p>

<ul>
<li>Technologists who've already made up their mind</li>
<li>Non-technologist entrepreneurs who need to be reassured</li>
</ul>


<p>At the end of the day, I doubt that many of these people actually cared
about my answers. They probably just wanted to know if we were on the same page or wanted to be reassured.</p>

<p>To be honest, as an engineer, I believe <strong>a great idea can be built with almost any
technology</strong>. They all have their pros/cons. No matter what stack you choose, you'll pay a
certain price for whatever advantages it offers. But really, the success or failure of your project has more to do with vision, leadership, execution, and market than technological choices.</p>

<p>Now that I'm an entrepreneur, I make technical decisions daily. When I choose
a specific technology, I need to be able to justify the decision to myself, my
partners/employees and potential investors. I make technical choices based on the project and company's vision.</p>

<p>For a project to be successful you must have a strong vision.
If you can convert your <strong>vision</strong> into a set of <strong>values</strong> to benchmark every decision, your path will be clear and it'll be easier to find the right people to join you.</p>

<p>Besides the vision, a lot of startups focus on culture.
It is commonly said that the culture is defined by the founders, the first few employees, and
the product itself.
However, what isn't often mentioned is that <strong>the technical
decisions will have a direct effect on the company culture</strong>.</p>

<p>Whether your new startup is based on J2EE/Oracle, Perl, PHP, Rails, Node.js or
.NET, the team's engineers will have different expectations, different
values, and different concerns. None of these technologies are intrinsically bad. Great things have been built with each. But they do come with a culture.</p>

<p>A couple years ago, I met an entrepreneur who chose to
build his application in Node.js. Curious, I asked why he chose Node.
The response was simple:
* smart engineers are excited about it so I can more easily recruit
* people are willing to contribute for free because it builds their
  experience</p>

<p>This decision clearly set the engineering culture and defined the team of people
who could work or be interested in working on the project.</p>

<h2>Asking a Different Question</h2>

<p>So maybe instead of asking what technology I should use, we should ask ourselves:</p>

<blockquote><p>Does this technology fit my company's core values?</p></blockquote>

<p>That's a much harder question because you need to actually <em>understand</em> your
core values. That understanding is key to building a successful product.</p>

<p>You can't blindly copy a tech stack in the same way you can't copy a business plan. It's a part of your company's identity. Your core values, your objectives, your team and your
expectations are different.</p>

<p>The whole <em>"it worked for X"</em> argument is
rarely valid. Look, Facebook uses PHP, it "worked for them". Does that mean we should all use PHP?</p>

<h2>Technology-Culture Alignment</h2>

<p>Characterizing communities is difficult, but I'll share with you the impressions and perspectives that I have on various options. Feel free to use the comments to share your own perspective and cover other communities.</p>

<h3>Old School</h3>

<p>Here are some of the "classics": languages that have been used for a
while and have proven their values. They're widespread, but don't inspire much passion anymore.</p>

<p><em>Note</em>: I omitted Perl because I personally don't know any new startups building their core technology in Perl (6?).</p>

<h2>PHP</h2>

<p><strong>Philosophy:</strong></p>

<ul>
<li>Get stuff done, that's what matters</li>
<li>It's like Basic for the Web</li>
<li>As long as there is a way to do it, it ain't broken</li>
<li>It works and it's fast, anything else is pointless</li>
<li>Don't be too academic, our language is accessible and anyone can be
started in no time. Try to do the same thing with Java!</li>
<li>Object orientation as an afterthought</li>
</ul>


<p><strong>Common use case: (as of mid-2013)</strong></p>

<ul>
<li>Your first web app</li>
<li>Extending Wordpress/Drupal</li>
</ul>


<p><strong>Personal opinion:</strong></p>

<p>PHP had its days of glory. It really made web development easy and
accessible. However, probably due to the really large amount of new programmers who
started with PHP and a not so opinionated community, very few people can
write good PHP.</p>

<p>Good idiomatic code examples are hard to find and I'm not even sure there is such as as idiomatic PHP. The result is a community known for poor code quality, lack of
tests, security nightmares and an after taste of the early 2000s.</p>

<p>Strong PHP teams with well established conventions, processes and guidelines can accomplish great things,
but such teams are rare.</p>

<h2>Java</h2>

<p><strong>Philosophy:</strong></p>

<ul>
<li>Portability</li>
<li>The power &amp; performance of C/C++ but with automatic memory management</li>
<li>Cares a lot about object-orientation</li>
<li>IDE required</li>
<li>Memory is cheap so we consume it <em>ALL</em></li>
<li>Threading is the way to go!</li>
<li>Don't mention Java applets</li>
<li>Look at my pretty JVM!</li>
<li>Open source (but owned by Oracle)</li>
<li>Slower but safer development cycles</li>
</ul>


<p><strong>Personal Opinion:</strong></p>

<p>Java is quite interesting. A few years ago a lot of developers got tired of Java and
explored other lands. They often switched to interpreted languages
such as PHP, Python, Ruby or more esoteric languages like Erlang.</p>

<p>However, Google via Android was able to show that Java in itself isn't as terrible
as we remembered (as long as you don't have to use J2EE or Swing).
There is also a "hipsterish" trend that seems to indicate that Java is
actually cool again. A lot of that has to do with two things:</p>

<ul>
<li>the JVM</li>
<li>the incredible quantity of high quality libraries</li>
</ul>


<p>That said, for a lot of us, writing Java all day long doesn't sound
 appealing. If you are going to rely on the Java stack, there is <a href="http://en.wikipedia.org/wiki/List_of_JVM_languages">long list of other JVM languages</a>
which are mature and play well with Java
libs (i.e: Scala, Groovy, JRuby, Clojure).
You can always to mix and match.</p>

<p>Hiring Java developers isn't too hard since most students coming out of school learned Java,
but finding great early-stage startup engineers who want to write Java is quite challenging.</p>

<p><em>Side note: If you are targeting Android, keep it simple, stay with the official
stack even if you might fancy another JVM language better.</em></p>

<p>There are still many reasons to use Java's technology for your new
startup, but you might also consider using a more "rapid/flexible" solution in parallel (Ruby,
Python, Node...). A multilingual environment brings a lot of value to
both the company and the engineers, which is something the Java
community seems to be slowly but surely discovering.</p>

<p>Java mainly attracts more classically trained engineers looking for
comfortable, repetitive, well known patterns. They will be used to the language, its
tools and its natural rhythm. They might not be the most curious
developers but they are reliable (if you pick the right ones obviously).</p>

<h2>C#/.NET</h2>

<p><strong>Philosophy:</strong></p>

<ul>
<li>A better Java</li>
<li>Originally designed for desktop and embedded apps</li>
<li>We have a better IDE than the Java guys</li>
<li>We are enterprise serious but we can offer you most of Rails' cool
features</li>
<li>We have a conflicted vision of Open Source</li>
<li>Slower but safer development cycles</li>
</ul>


<p><strong>Personal Opinion:</strong></p>

<p>I went back and looked at C# when C# 5 was released and I have to say
that I was really impressed by some of the new language features. From a
purely language design perspective, C# is quite a bit ahead of Java. I was
also surprised by how pleasant it was to write Javascript in Visual
Studio (I really didn't expect that since my experience with VS was
mainly around C++).</p>

<p>Another thing that really impressed me: the quality level of the
available documentation is outstanding!
But the fact that C# isn't open source, that Visual Studio + MSDN is so expensive and
the whole environment reeks of licenses and costs, is bit of a turn off.</p>

<p>Microsoft is slowly opening up to open source and more open solutions like Azure. But as a
community, .NET is still quite Microsoft-centered.
As a startup entrepreneur, you should consider how you feel about open source vs enterprise backed cultures.</p>

<p>C# mainly attracts a variant of the Java crowd: engineers seeking stability and a support contract over open source. And they can tolerate IIS!</p>

<h3>Established Alternatives</h3>

<p>Over the years, two dynamic languages became cherished by startups:
Python and Ruby. The two languages are
actually quite similar. Nowadays Python is quite popular for backend apps
(NLP, biotech, APIs, SOA elements) while Ruby is more popular for
consumer-facing apps.
Both of these languages suffer from the same limitations (mainly
performance and concurrency) but their core
values and communities have different focuses.</p>

<h2>Python</h2>

<p><strong>Philosophy:</strong></p>

<ul>
<li>Only one obvious way to do things</li>
<li>Code has to be beautiful, simple and explicit</li>
<li>Documentation is critical</li>
<li>Strong language design leadership</li>
</ul>


<p><strong>Personal Opinion:</strong></p>

<p>As someone who chose Ruby over Python, I often envy the quality of
the documentation you find in Python projects.
I also have a love/hate relationship with the fact that Python is
designed to give you just one right way. This is
often great for teams, but it can also be frustrating.</p>

<p>In some areas, Python has some of the best libraries out there, and
depending on the problems you are tackling, Python might be the right
choice. Python developers know how to communicate about their code. They document what they do
and are process oriented while being pragmatic about their
approaches.</p>

<p>But Python was created way before the internet became
popular and if concurrency and high throughput is a concern for you, a
dynamic, interpreted language with poor concurrency might not be the right choice.</p>

<p>Python mainly attracts more pragmatic, experienced, full-stack developers
wanting a modern but well-proven language.</p>

<h2>Ruby/Ruby on Rails</h2>

<p><strong>Philosphy:</strong></p>

<ul>
<li>Designed for humans, not machines</li>
<li>Extreme flexibility: if you mess up, it's on you</li>
<li>Everything has to be easy, elegant and fun</li>
<li>DSL on top of DSLs on top of DSLs</li>
<li>Testing is critical</li>
<li>Things move quickly, learn to keep up</li>
<li>Passionate and vibrant community</li>
</ul>


<p><strong>Personal opinion:</strong></p>

<p>As far as I'm concerned, Ruby has been my go-to language for years.
You will find an incredible, sometimes overwhelming amount of Ruby open
source code. Rails is really an amazing web framework making most web
projects easy to implement if you know how to use the tool.</p>

<p>But the flexibility and rapid development cycle also have
downsides. Be ready to invest a large chunk of your time keeping your code
base up to date and migrating away from abandoned libraries.
If you can't rely on caching, the throughput of a successful app will often be limited
by the lack of good concurrency support.</p>

<p>Ruby developers are mainly Rails developers and a great majority might
have a hard time being able to identify core language features versus
framework features. They are often curious, opportunistic (in a good way),
somewhat pragmatic and care about code quality/structure and
test coverage. Rails developers are typically early adopters due to
the fact that the framework itself uses some new technologies by
default (coffeescript, turbolinks, CSS pre-processors...).</p>

<p>Ruby and Rails mainly attract developers wanting to get things done
quickly but elegantly. These developers are often
product-oriented and care more about the purpose and customer value  than the lower-level computational details.</p>

<h2>New Players</h2>

<p>These are the languages/technologies that get people excited. They
represent the new wave of programming languages designed to run
in "the cloud".</p>

<h2>Node.js (Javascript)</h2>

<p>Node.js isn't a programming language but it's the most popular way to
run JS server side. The same way most of my comments about Ruby were
about Rails, I'll focus on Node more than JS itself.</p>

<p><strong>Philosophy:</strong></p>

<ul>
<li>Designed for real-time driven apps with high throughput, low latency</li>
<li>DIY</li>
<li>Small core, the rest is up to the community</li>
<li>Coupling is a sin</li>
<li>Learned lessons from Ruby/Python</li>
</ul>


<p><strong>Personal Opinion:</strong></p>

<p>I find Node.js interesting. Technically there isn't much new with Node. Python has
Tornado/Twisted, Ruby has EventMachine, and C had libevent.</p>

<p>Event-driven frameworks have
been used for a while but Node has two major advantages:
* most JS libs are non-blocking
* most web developers have to write some JS anyway</p>

<p>The idea of using the same
programming language both in the front end and the back end appeals to many, but the value is still unproven.</p>

<p>Node offers great throughput (as long as you stick to IO operations),
is easy to get started, and is fun to write.</p>

<p>Due to the nature of event-based programming, debugging and testing is challenging. Dealing with callbacks can be maintenance hell. I hope that Node will adopt an official future/promise solution. And documentation is typically spotty making jumping on an existing project difficult.</p>

<p>Node developers are definitely early adopters and comfortable creating a custom structure/pattern rather than following convention.It attracts developers wanting to use a known language (JS)
to handle high levels of concurrency. Node as a framework is lower level than the classical MVCs which is a plus for hackers. Node developers also really like the idea of using the same programming language on both server and client.</p>

<h2>Clojure</h2>

<p><strong>Philosophy:</strong></p>

<ul>
<li>A pragmatic and modern Lisp</li>
<li>Everything is data</li>
<li>Concurrency, concurrency, concurrency</li>
<li>States are evil</li>
<li>Great Java interoperability</li>
<li>A bit on the academic side, but still being pragmatic</li>
</ul>


<p><strong>Personal Opinion:</strong></p>

<p>What I like the most about Clojure is the lisp
spirit.
Once you get past the parenthesis and the operator/argument order,
Clojure challenges you to entirely rethink the way you architect your code.
It's really good and efficient at processing data and pushes you to keep
your code short.</p>

<p>My problem with Clojure is that I'm not smart enough to write a lot of
it. My brain quickly stack overflows trying to follow the data.
Exceptions are often meaningless and trying to debug someone else's code is
challenging since the language itself is complex and it can be extended
by macros. Finally, the Clojure community isn't really web-oriented,
most of the work done in Clojure seems to be data-centric.</p>

<p>Clojure mainly attracts more fringe, language-curious, data-oriented programmers. If you are looking for data scientists with a programming language fetish,
Clojure is a good way to attract them.</p>

<h2>Scala</h2>

<p><strong>Philosophy:</strong></p>

<ul>
<li>Have the best of both object oriented and functional programming worlds</li>
<li>Let the compiler do some of the work for you</li>
<li>Concurrency matters</li>
<li>Less ceremony than Java, but aiming for same or better performance</li>
<li>Live in harmony with the Java ecosystem</li>
</ul>


<p><strong>Personal Opinion:</strong></p>

<p>Scala is currently my language of choice when targeting the JVM. The learning curve is steep. Knowing
when to use FP vs OOP can be tricky and so is dealing with the
language syntax itself.</p>

<p>That said, getting the benefits of using FP, while
still keeping OOP when needed, is very useful.
Once you "get" the language idioms, writing Scala is actually pleasant
and the community is quite nice.</p>

<p>The <a href="http://www.playframework.com/">Play</a>
framework is really good and offers a good alternative to Rails,
especially for API development. Twitter's engineering team offers a lot of resources and open source code.</p>

<p>Using Scala is a pretty safe bet at this point. Java developers feel
confortable and get to try a more "modern" language. Dynamic
language developers don't feel too far from home but get the Java
ecosystem, the performance boost, concurrency and immutability.
The tooling and convetions make using Scala on a
growing team quite nice, if the compilation time doesn't get you down.</p>

<p>Like Ruby, though, the Scala community isn't big on documentation.
I really hope <a href="http://www.scala-lang.org/api/current/">the API doc</a> will be rewritten to be more intuitive and overall more useful.
But to be fair there are a lot of great resources out there such as
<a href="http://twitter.github.io/scala_school/">Twitter's Scala school</a> and
<a href="https://www.coursera.org/course/progfun">Coursera's FP in Scala class</a> given
by Martin Odersky (Scala's creator).</p>

<p>Scala mainly attracts curious Java developers wanting
something more modern as well as Ruby/Python developers wanting a more scalable version of their language.
Scala is a good way to attract great developers who want to push
the boundaries of their existing dev environment as well as developers being able to leverage the duality of the language.</p>

<h2>Go</h2>

<ul>
<li>A better C</li>
<li>Memory management is handled for you, but don't be wreckless</li>
<li>Explicit is better than implicit</li>
<li>Rich built-in functionality</li>
<li>Fast.. everything (from compilation to execution)</li>
<li>Concurrency built-in and made easy</li>
<li>Documentation is critical</li>
</ul>


<p><strong>Personal Opinion:</strong></p>

<p>I really like Go (aka Golang). After playing with it for years, I chose to use it to
develop the APIs of my own startup. Go might sound boring to some, but
its simplicity and efficiency just work.</p>

<p>Go forces you to think a bit more about how you structure your
data/behavior because you can't just stick to the usual OO patterns. I've found that my code ends up being easier
to follow and simpler in structure, yet sometimes a bit more repetitive (ex: error handling).</p>

<p>Concurrency can't get much easier than Go. While it is compiled, your code compiles and boots in less time than a Rails server starts up. Go supports some form of duck typing making the transition from Ruby (for instance) quite easy. The production performance is quite amazing when coming from
a scripting language and the memory footprint stays small.</p>

<p>Go is designed so a single user or a big team can work on the same codebase and the tooling around the language is really great.</p>

<p>However, it's not a perfect language. 3rd party dependency management can be tricky at
times. The code can feel too low-level when you're used to high-level programming languages. And some of the language design decisions can cause confusion at times (ex: interacting with interfaces vs structs).</p>

<p>Go seems to become quite popular within the startup scene when
performance and concurrency matters. I've seen a good number of startups migrating from Node to Go and others simply extending their stack by adding small Go apps.</p>

<p>The Go community seems to be a mix of old school hackers coming from C/C++ and a younger crowd enjoying a lower-level language.
The language and the community leaders are opinionated which makes
understanding their vision and approach easy. It also allows you to
quickly evaluate how comfortable you are with their philosophy and see if it matches your expectations.</p>

<p>Go mainly attracts performance/architecture oriented developers.
They want easy concurrency, the execution speed of C with the development speed of
Python/Ruby. They don't look for a new fun language, they look for a
solid compromise.</p>

<h2>Technology Drives Culture</h2>

<p>Technical decisions have cultural impact. Think clearly and carefully about <strong>how your technologies align with your company's core values</strong>. Make the right choices and you'll spend less time fighting about technical details and more time building a great business.</p>

<p>And if you miss those arguments, there's always <a href="http://news.ycombinator.com/">hackernews</a>.</p>

<hr />

<br/>


<p><em>Update</em>: Speaking of HN, <a href="https://news.ycombinator.com/item?id=6285129">here is the thread for this post</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang multipart file upload example]]></title>
    <link href="http://mattetti.github.com/posts/2013/07/01/golang-multipart-file-upload-example/"/>
    <updated>2013-07-01T22:28:00-07:00</updated>
    <id>http://mattetti.github.com/posts/2013/07/01/golang-multipart-file-upload-example</id>
    <content type="html"><![CDATA[<p>The Go language is one of my favorite programming languages. However,
sometimes doing simple things can seem a bit harder than it should.
However, most of the time, the problem is just to find out how to
do things the easy way. While Go's documention isn't bad, the real key
to finding out how to do things is often to look at the <a href="http://golang.org/src/pkg/mime/multipart/">source code</a> and
the <a href="http://golang.org/src/pkg/mime/multipart/multipart_test.go">test suite</a>.</p>

<p>I'm not yet super familiar with all the std lib packages, so when I
wanted to test my Go web services, I wrote a few lines of code to create
a multipart file upload function that was building the body from scratch.
Once I was done messing with the various headers, boundary protocol etc..
I started testing some edge cases, I found some bugs in my code.
Looking at Go's packages, I realized that all the tools were already
available for me to use. I was just lacking a good example. Walking
through the test suite I finally figured out how to write a simple
multipart file upload example with some extra query params.</p>

<p>Hopefully this example will be helpful to some of you.</p>

<p>```go
package main</p>

<p>import (</p>

<pre><code>"bytes"
"fmt"
"io"
"log"
"mime/multipart"
"net/http"
"os"
"path/filepath"
</code></pre>

<p>)</p>

<p>// Creates a new file upload http request with optional extra params
func newfileUploadRequest(uri string, params map[string]string, paramName, path string) (*http.Request, error) {</p>

<pre><code>file, err := os.Open(path)
if err != nil {
    return nil, err
}
defer file.Close()

body := &amp;bytes.Buffer{}
writer := multipart.NewWriter(body)
part, err := writer.CreateFormFile(paramName, filepath.Base(path))
if err != nil {
    return nil, err
}
_, err = io.Copy(part, file)

for key, val := range params {
    _ = writer.WriteField(key, val)
}
err = writer.Close()
if err != nil {
    return nil, err
}

return http.NewRequest("POST", uri, body)
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>path, _ := os.Getwd()
path += "/test.pdf"
extraParams := map[string]string{
    "title":       "My Document",
    "author":      "Matt Aimonetti",
    "description": "A document with all the Go programming language secrets",
}
request, err := newfileUploadRequest("https://google.com/upload", extraParams, "file", "/tmp/doc.pdf")
if err != nil {
    log.Fatal(err)
}
client := &amp;http.Client{}
resp, err := client.Do(request)
if err != nil {
    log.Fatal(err)
} else {
    body := &amp;bytes.Buffer{}
    _, err := body.ReadFrom(resp.Body)
if err != nil {
        log.Fatal(err)
    }
resp.Body.Close()
    fmt.Println(resp.StatusCode)
    fmt.Println(resp.Header)
    fmt.Println(body)
}
</code></pre>

<p>}
```</p>

<p><a href="https://gist.github.com/mattetti/5914158">Example's source code on GitHub</a></p>

<p>All the work is done in the <code>newfileUploadRequest</code> function and
really, the <code>mime/multipart</code> package hides all the complexity of
creating a multipart request.</p>

<p>The key is to set a new <code>multipart.Writer</code>:</p>

<p><code>go
writer := multipart.NewWriter(body)
</code></p>

<p>The writer will do all the work and will write directly to our body (which itself is a buffer of bytes).</p>

<p>We then create a part for the file form entry with the name of the file
param and the name of the file (that we extracted using the <code>path/filepath</code>
package).
We need to add the content of the file to the file part, we use the
<code>io.Copy()</code> to do so. In the first version of this article, I had used
<code>io/ioutil</code> <code>Readall</code> to read the content of the file (see code <a href="https://gist.github.com/mattetti/5914158/f4d1393d83ebedc682a3c8e7bdc6b49670083b84">here</a>).
However a few readers rightfully mentioned that I should instead copy
content from the file to the part instead of temporarily loading the content of
the file in memory. <a href="http://play.golang.org/p/eEFBMGMNTW">Here</a> is an
even more optimized version using goroutine to stream the data, and
<a href="https://github.com/gebi/go-fileupload-example/blob/master/main.go">here</a> is the full example using a pipe.</p>

<p><code>go
part, _ := writer.CreateFormFile(paramName, filepath.Base(path))
_, err = io.Copy(part, file)
</code></p>

<p>The <code>multipart.Writer</code> takes care of setting the boundary and formating
the form data for us, nice isn't it?!</p>

<p>Then for any extra params passed as a map of string keys to string
value, we use another function of the <code>multipart.Writer</code> type:</p>

<p><code>go
writer.WriteField(key, val)
</code></p>

<p>Once again, the writer takes care of creating the right headers, and to
add the passed value.</p>

<p>At this point, we just need to close our writer and use our body to
create a new request.</p>

<p><code>go
writer.Close()
req, _ := http.NewRequest("POST", uri, body)
</code></p>

<p>One last thing before triggering our request, we need to set the header
that contains the content type including the boundary being used.
Once again, the Go lib has us covered:</p>

<p><code>go
req.Header.Add("Content-Type", writer.FormDataContentType())
</code></p>

<p>As a reference, here is the generated body:</p>

<p>```
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="file"; filename="doc.pdf"
Content-Type: application/octet-stream</p>

<p>%PDF-1.4
%????
4 0 obj
&lt;&lt;/Type /Catalog
// removed for example
trailer
&lt;&lt;/Size 18
/Root 4 0 R</p>

<blockquote><blockquote><p>startxref
45054
%%EOF
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="title"</p></blockquote></blockquote>

<p>My Document
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="author"</p>

<p>Matt Aimonetti
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="description"</p>

<p>A document with all the Go programming language secrets
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee--</p>

<p>```</p>

<p>Golang might not be as high level as Ruby or Python, but it's not too
far off and it certainly comes with some great std libs.
I know I recently caught myself writing a lot of small scripts in Go,
something I used to do in Ruby. I think this is mainly due to the
fact that Go is compiled, designed for concurrency, has great std libs and
is quite easy to write.</p>

<p><em>Hopefully this code sample illustrates how easy Go can be and can also
serve as a reference point if you are looking for a way to do multipart
upload.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Go vs Ruby for web APIs]]></title>
    <link href="http://mattetti.github.com/posts/2013/06/23/using-go-vs-ruby-for-web-apis/"/>
    <updated>2013-06-23T09:50:00-07:00</updated>
    <id>http://mattetti.github.com/posts/2013/06/23/using-go-vs-ruby-for-web-apis</id>
    <content type="html"><![CDATA[<p>A few days ago, I was wondering if using <a href="http://golang.org/">Go</a> would be worth it when developing new web APIs.
I obviously knew that Go would be faster than Ruby, but I wasn't sure
how much faster. I also wondering about the amount of work required to
write get a full API implemented.</p>

<p>I therefore wrote the same web API in Ruby (using Rails) and in Go (at
first using Revel and then rewriting it without a framework since Go's
std lib have everything one might need).
The API spec was simple:
* extract an authorization token contained in the request header
* use the token to query a MySQL database
* respond by sending back the MySQL row in json format
* return 401 if the token isn't value</p>

<p>I didn't try to optimize the Ruby code, nor the Go code. The idea wasn't
to get precise benchmark results, the goal was to get an idea of how
much faster Go was in a real life situation. The other goal was to
evaluate the amount of work needed to write web APIs in Go for someone
who already knows the language.</p>

<p>At the end of the day the API implemented in Go is more than 50x faster than
the Ruby version. Interesting enough, writing the code and tests for the
Go API was pretty close to the Ruby experience (more on that later).
50X performance gain, including high concurrency support might be a very
good argument to start using some Go when it makes sense.</p>

<p>I documented my experiment on <a href="https://plus.google.com/101114877505962271216/posts/PeZk8FY3PWY">Google+</a>, click the following screenshot to read more.</p>

<p><a href="https://plus.google.com/101114877505962271216/posts/PeZk8FY3PWY"><img src="/images/matt_aimonetti-golang_vs_ruby_api_exp.png" alt="Matt Aimonetti's Go vs Ruby post on Google+" /></a></p>
]]></content>
  </entry>
  
</feed>
